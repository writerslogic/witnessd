// Package vdf implements the Pietrzak Verifiable Delay Function.
//
// Unlike iterated hash chains which require O(t) verification time,
// Pietrzak VDF provides succinct proofs with O(log t) verification time.
//
// The construction uses repeated squaring in an RSA group:
//   y = x^(2^t) mod N
//
// The proof uses a recursive halving protocol:
// 1. Prover computes μ = x^(2^(t/2)) (the "midpoint")
// 2. Verifier sends random challenge r
// 3. Both sides compute x' = x^r · μ and y' = μ^r · y
// 4. Recurse with (x', y', t/2)
//
// This yields O(log t) proof size and O(log t) verification time.
//
// References:
// - Pietrzak, K. "Simple Verifiable Delay Functions" (ITCS 2019)
// - Boneh et al. "A Survey of Two Verifiable Delay Functions" (2018)
package vdf

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/binary"
	"errors"
	"fmt"
	"math/big"
	"time"
)

var (
	// ErrInvalidProof is returned when proof verification fails.
	ErrInvalidProof = errors.New("invalid VDF proof")

	// ErrInvalidParameters is returned for invalid VDF parameters.
	ErrInvalidParameters = errors.New("invalid VDF parameters")

	// ErrUntrustedModulus is returned when using a modulus with known factorization.
	ErrUntrustedModulus = errors.New("modulus factorization may be known - use RSA challenge or class groups")

	// RSA-2048 Challenge Modulus (RSA Factoring Challenge, never factored)
	//
	// SECURITY PROPERTIES:
	// - This number was generated by RSA Laboratories in 1991
	// - The factors were destroyed after generation
	// - As of 2024, no one has publicly factored this number
	// - Prize was $200,000 (challenge ended, but number remains unfactored)
	//
	// WHY THIS MATTERS FOR VDF:
	// - If you know p,q where N=p*q, you can compute x^(2^t) in O(log t) time
	// - Using Euler's theorem: x^(2^t) = x^(2^t mod φ(N)) where φ(N)=(p-1)(q-1)
	// - With unknown factorization, must do t sequential squarings (no shortcut)
	//
	// TRUST MODEL:
	// - Must trust that RSA Labs destroyed the factors
	// - If factors were ever leaked, all proofs become instantly forgeable
	// - For higher assurance, use class groups (no trapdoor possible)
	//
	// Source: https://en.wikipedia.org/wiki/RSA_numbers#RSA-2048
	rsaChallenge2048, _ = new(big.Int).SetString(
		"25195908475657893494027183240048398571429282126204032027777137836043662020707595556264018525880784406918290641249515082189298559149176184502808489120072844992687392807287776735971418347270261896375014971824691165077613379859095700097330459748808428401797429100642458691817195118746121515172654632282216869987549182422433637259085141865462043576798423387184774447920739934236584823824281198163815010674810451660377306056201619676256133844143603833904414952634432190114657544454178424020924616515723350778707749817125772467962926386356373289912154831438167899885040445364023527381951378636564391212010397122822120720357",
		10)

	// defaultModulus uses the RSA-2048 challenge for the default configuration.
	// This provides security assuming RSA Labs destroyed the factors.
	defaultModulus = rsaChallenge2048
)

// PietrzakParams holds Pietrzak VDF parameters.
type PietrzakParams struct {
	// N is the RSA modulus (should be product of two safe primes).
	//
	// CRITICAL SECURITY REQUIREMENT:
	// The factorization of N must be unknown to EVERYONE, including:
	// - The prover generating the VDF proof
	// - The verifier checking the proof
	// - The system administrator
	// - The software developer
	//
	// If anyone knows the factorization p,q where N=p*q, they can:
	// - Compute x^(2^t) mod N in O(log t) time instead of O(t)
	// - Forge proofs instantly, defeating the entire purpose of the VDF
	//
	// Safe options for N:
	// 1. RSA Factoring Challenge numbers (factors destroyed by RSA Labs)
	// 2. Class groups of imaginary quadratic fields (no trapdoor possible)
	// 3. Modulus generated via MPC ceremony (no single party knows factors)
	//
	// UNSAFE: Generating N locally by picking primes - the generator knows factors!
	N *big.Int

	// T is the time parameter (number of squarings).
	// Actual delay is T sequential squarings.
	T uint64

	// Lambda is the security parameter (typically 128).
	Lambda int

	// AllowUntrustedModulus, if true, allows using any modulus without validation.
	// WARNING: Only set this if you understand the security implications.
	// A prover who knows the factorization can forge proofs instantly.
	AllowUntrustedModulus bool
}

// DefaultPietrzakParams returns default parameters suitable for minutes-scale delays.
func DefaultPietrzakParams() PietrzakParams {
	return PietrzakParams{
		N:      new(big.Int).Set(defaultModulus),
		T:      1 << 20, // ~1M squarings, roughly 1 second on modern CPU
		Lambda: 128,
	}
}

// PietrzakProof holds the Pietrzak VDF proof.
// The proof consists of intermediate values at each recursion level.
type PietrzakProof struct {
	// Input is the starting point x.
	Input *big.Int

	// Output is the result y = x^(2^T) mod N.
	Output *big.Int

	// T is the time parameter.
	T uint64

	// Intermediates are the μ values at each recursion level.
	// Length is O(log T).
	Intermediates []*big.Int

	// ComputeTime is how long evaluation took.
	ComputeTime time.Duration
}

// PietrzakVDF implements the Pietrzak VDF construction.
type PietrzakVDF struct {
	params PietrzakParams

	// Cache for squaring operations (optional optimization)
	squareCache map[string]*big.Int
}

// NewPietrzakVDF creates a new Pietrzak VDF instance.
func NewPietrzakVDF(params PietrzakParams) (*PietrzakVDF, error) {
	if params.N == nil || params.N.Sign() <= 0 {
		return nil, ErrInvalidParameters
	}
	if params.T == 0 {
		return nil, ErrInvalidParameters
	}

	// Validate modulus security unless explicitly bypassed
	if !params.AllowUntrustedModulus {
		if !IsKnownSafeModulus(params.N) {
			return nil, fmt.Errorf("%w: modulus is not a known RSA challenge number", ErrUntrustedModulus)
		}
	}

	return &PietrzakVDF{
		params:      params,
		squareCache: make(map[string]*big.Int),
	}, nil
}

// IsKnownSafeModulus checks if the modulus is a known RSA challenge number
// with unknown factorization. Returns false for any other modulus.
func IsKnownSafeModulus(n *big.Int) bool {
	if n == nil {
		return false
	}
	// Check against known RSA challenge numbers
	return n.Cmp(rsaChallenge2048) == 0
}

// KnownSafeModuli returns the list of known safe moduli that can be used.
func KnownSafeModuli() []*big.Int {
	return []*big.Int{
		new(big.Int).Set(rsaChallenge2048),
	}
}

// Evaluate computes y = x^(2^T) mod N and generates the proof.
// This is the slow operation that takes O(T) sequential squarings.
func (v *PietrzakVDF) Evaluate(x *big.Int) (*PietrzakProof, error) {
	if x.Sign() <= 0 || x.Cmp(v.params.N) >= 0 {
		return nil, ErrInvalidParameters
	}

	start := time.Now()

	// Compute the full chain: x, x^2, x^4, ..., x^(2^T)
	// Store ALL intermediate values - we need x^(2^i) for any i
	chain := v.computeChainWithIntermediates(x)

	// Generate proof using Fiat-Shamir recursive halving
	intermediates := v.generateProofIntermediates(chain)

	proof := &PietrzakProof{
		Input:         new(big.Int).Set(x),
		Output:        chain[len(chain)-1],
		T:             v.params.T,
		Intermediates: intermediates,
		ComputeTime:   time.Since(start),
	}

	return proof, nil
}

// computeChainWithIntermediates computes the full squaring chain,
// storing all intermediate values needed for proof generation.
func (v *PietrzakVDF) computeChainWithIntermediates(x *big.Int) []*big.Int {
	// We need to store x^(2^i) for all i from 0 to T
	// For efficiency, we only store values at specific checkpoints
	chain := make([]*big.Int, v.params.T+1)
	chain[0] = new(big.Int).Set(x)

	current := new(big.Int).Set(x)
	for i := uint64(1); i <= v.params.T; i++ {
		current = new(big.Int).Mul(current, current)
		current.Mod(current, v.params.N)
		chain[i] = new(big.Int).Set(current)
	}

	return chain
}

// generateProofIntermediates generates the μ values using Fiat-Shamir.
// At each level, μ = x^(2^(t/2)) is the midpoint value.
// The proof uses deterministic challenges derived from x, y, μ.
func (v *PietrzakVDF) generateProofIntermediates(chain []*big.Int) []*big.Int {
	levels := bitLength(v.params.T)
	intermediates := make([]*big.Int, 0, levels)

	// Start with the full evaluation
	// chain[i] = x^(2^i), so chain[0] = x, chain[T] = y
	x := new(big.Int).Set(chain[0])
	y := new(big.Int).Set(chain[v.params.T])
	t := v.params.T
	level := 0

	for t > 1 {
		halfT := t / 2

		// μ = x^(2^(t/2)) from the original chain
		// Since chain[i] = original_x^(2^i), we need to find the right value
		// At the first level, μ = chain[halfT]
		// But after updating x, we need to compute μ differently

		// For the first level, μ = chain[halfT]
		if level == 0 {
			mu := new(big.Int).Set(chain[halfT])
			intermediates = append(intermediates, mu)

			// Generate challenge for next iteration
			r := v.generateChallenge(x, y, mu, t, level)

			// Update x' = x^r * μ (mod N)
			xPrime := new(big.Int).Exp(x, r, v.params.N)
			xPrime.Mul(xPrime, mu)
			xPrime.Mod(xPrime, v.params.N)

			// Update y' = μ^r * y (mod N)
			yPrime := new(big.Int).Exp(mu, r, v.params.N)
			yPrime.Mul(yPrime, y)
			yPrime.Mod(yPrime, v.params.N)

			x = xPrime
			y = yPrime
		} else {
			// For subsequent levels, we need to compute μ = x'^(2^(t/2))
			// This requires re-computing since x has changed
			mu := new(big.Int).Set(x)
			for i := uint64(0); i < halfT; i++ {
				mu.Mul(mu, mu)
				mu.Mod(mu, v.params.N)
			}
			intermediates = append(intermediates, mu)

			// Generate challenge
			r := v.generateChallenge(x, y, mu, t, level)

			// Update x' = x^r * μ
			xPrime := new(big.Int).Exp(x, r, v.params.N)
			xPrime.Mul(xPrime, mu)
			xPrime.Mod(xPrime, v.params.N)

			// Update y' = μ^r * y
			yPrime := new(big.Int).Exp(mu, r, v.params.N)
			yPrime.Mul(yPrime, y)
			yPrime.Mod(yPrime, v.params.N)

			x = xPrime
			y = yPrime
		}

		t = halfT
		level++
	}

	return intermediates
}

// Verify checks the Pietrzak VDF proof in O(log T) time.
func (v *PietrzakVDF) Verify(proof *PietrzakProof) bool {
	if proof == nil || proof.Input == nil || proof.Output == nil {
		return false
	}

	// Check basic bounds
	if proof.Input.Sign() <= 0 || proof.Input.Cmp(v.params.N) >= 0 {
		return false
	}
	if proof.Output.Sign() <= 0 || proof.Output.Cmp(v.params.N) >= 0 {
		return false
	}

	// Verify using recursive halving
	x := new(big.Int).Set(proof.Input)
	y := new(big.Int).Set(proof.Output)
	t := proof.T

	for i, mu := range proof.Intermediates {
		if t <= 1 {
			break
		}

		// Generate Fiat-Shamir challenge
		r := v.generateChallenge(x, y, mu, t, i)

		// Compute x' = x^r * μ (mod N)
		xPrime := new(big.Int).Exp(x, r, v.params.N)
		xPrime.Mul(xPrime, mu)
		xPrime.Mod(xPrime, v.params.N)

		// Compute y' = μ^r * y (mod N)
		yPrime := new(big.Int).Exp(mu, r, v.params.N)
		yPrime.Mul(yPrime, y)
		yPrime.Mod(yPrime, v.params.N)

		// Update for next iteration
		x = xPrime
		y = yPrime
		t = t / 2
	}

	// Final check: y should equal x^(2^t) for small t
	if t > 0 {
		expected := new(big.Int).Set(x)
		for i := uint64(0); i < t; i++ {
			expected.Mul(expected, expected)
			expected.Mod(expected, v.params.N)
		}
		return expected.Cmp(y) == 0
	}

	return x.Cmp(y) == 0
}

// generateChallenge creates the Fiat-Shamir challenge for each level.
func (v *PietrzakVDF) generateChallenge(x, y, mu *big.Int, t uint64, level int) *big.Int {
	h := sha256.New()
	h.Write([]byte("pietrzak-vdf-challenge"))
	h.Write(x.Bytes())
	h.Write(y.Bytes())
	h.Write(mu.Bytes())
	binary.Write(h, binary.BigEndian, t)
	binary.Write(h, binary.BigEndian, uint64(level))

	hash := h.Sum(nil)

	// Convert to big.Int in range [1, 2^λ]
	r := new(big.Int).SetBytes(hash[:v.params.Lambda/8])
	// Ensure r is positive and not too small
	if r.Sign() == 0 {
		r.SetInt64(1)
	}

	return r
}

// bitLength returns the number of bits needed to represent n.
func bitLength(n uint64) int {
	if n == 0 {
		return 0
	}
	bits := 0
	for n > 0 {
		bits++
		n >>= 1
	}
	return bits
}

// PietrzakProofSize returns the proof size in bytes.
func (p *PietrzakProof) PietrzakProofSize() int {
	// Each intermediate is ~256 bytes (2048-bit modulus)
	return len(p.Intermediates) * 256
}

// VerificationTime estimates the verification time.
// Verification is O(log T) exponentiations.
func (p *PietrzakProof) VerificationOps() int {
	// Two exponentiations per level
	return 2 * len(p.Intermediates)
}

// Encode serializes the proof.
func (p *PietrzakProof) Encode() ([]byte, error) {
	// Format: T (8 bytes) | input len (4) | input | output len (4) | output |
	//         num intermediates (4) | [intermediate len (4) | intermediate]...

	var buf []byte

	// T
	tBytes := make([]byte, 8)
	binary.BigEndian.PutUint64(tBytes, p.T)
	buf = append(buf, tBytes...)

	// Input
	inputBytes := p.Input.Bytes()
	lenBytes := make([]byte, 4)
	binary.BigEndian.PutUint32(lenBytes, uint32(len(inputBytes)))
	buf = append(buf, lenBytes...)
	buf = append(buf, inputBytes...)

	// Output
	outputBytes := p.Output.Bytes()
	binary.BigEndian.PutUint32(lenBytes, uint32(len(outputBytes)))
	buf = append(buf, lenBytes...)
	buf = append(buf, outputBytes...)

	// Compute time
	ctBytes := make([]byte, 8)
	binary.BigEndian.PutUint64(ctBytes, uint64(p.ComputeTime))
	buf = append(buf, ctBytes...)

	// Intermediates
	binary.BigEndian.PutUint32(lenBytes, uint32(len(p.Intermediates)))
	buf = append(buf, lenBytes...)

	for _, inter := range p.Intermediates {
		interBytes := inter.Bytes()
		binary.BigEndian.PutUint32(lenBytes, uint32(len(interBytes)))
		buf = append(buf, lenBytes...)
		buf = append(buf, interBytes...)
	}

	return buf, nil
}

// DecodePietrzakProof deserializes a proof.
func DecodePietrzakProof(data []byte) (*PietrzakProof, error) {
	if len(data) < 24 {
		return nil, errors.New("proof data too short")
	}

	offset := 0

	// T
	t := binary.BigEndian.Uint64(data[offset:])
	offset += 8

	// Input
	inputLen := binary.BigEndian.Uint32(data[offset:])
	offset += 4
	if offset+int(inputLen) > len(data) {
		return nil, errors.New("invalid input length")
	}
	input := new(big.Int).SetBytes(data[offset : offset+int(inputLen)])
	offset += int(inputLen)

	// Output
	if offset+4 > len(data) {
		return nil, errors.New("missing output length")
	}
	outputLen := binary.BigEndian.Uint32(data[offset:])
	offset += 4
	if offset+int(outputLen) > len(data) {
		return nil, errors.New("invalid output length")
	}
	output := new(big.Int).SetBytes(data[offset : offset+int(outputLen)])
	offset += int(outputLen)

	// Compute time
	if offset+8 > len(data) {
		return nil, errors.New("missing compute time")
	}
	computeTime := time.Duration(binary.BigEndian.Uint64(data[offset:]))
	offset += 8

	// Intermediates
	if offset+4 > len(data) {
		return nil, errors.New("missing intermediates count")
	}
	numInter := binary.BigEndian.Uint32(data[offset:])
	offset += 4

	intermediates := make([]*big.Int, numInter)
	for i := uint32(0); i < numInter; i++ {
		if offset+4 > len(data) {
			return nil, errors.New("missing intermediate length")
		}
		interLen := binary.BigEndian.Uint32(data[offset:])
		offset += 4
		if offset+int(interLen) > len(data) {
			return nil, errors.New("invalid intermediate length")
		}
		intermediates[i] = new(big.Int).SetBytes(data[offset : offset+int(interLen)])
		offset += int(interLen)
	}

	return &PietrzakProof{
		Input:         input,
		Output:        output,
		T:             t,
		Intermediates: intermediates,
		ComputeTime:   computeTime,
	}, nil
}

// GenerateRandomInput generates a random VDF input.
func (v *PietrzakVDF) GenerateRandomInput() (*big.Int, error) {
	// Generate random bytes
	bytes := make([]byte, (v.params.N.BitLen()+7)/8)
	_, err := rand.Read(bytes)
	if err != nil {
		return nil, err
	}

	// Convert to big.Int and reduce mod N
	x := new(big.Int).SetBytes(bytes)
	x.Mod(x, v.params.N)

	// Ensure x is in valid range [2, N-1]
	if x.Cmp(big.NewInt(2)) < 0 {
		x.Add(x, big.NewInt(2))
	}

	return x, nil
}

// InputFromBytes creates a VDF input from arbitrary bytes (e.g., content hash).
func (v *PietrzakVDF) InputFromBytes(data []byte) *big.Int {
	// Hash the data
	h := sha256.Sum256(data)

	// Convert to big.Int and ensure it's in valid range
	x := new(big.Int).SetBytes(h[:])
	x.Mod(x, v.params.N)

	// Ensure x >= 2
	if x.Cmp(big.NewInt(2)) < 0 {
		x.Add(x, big.NewInt(2))
	}

	return x
}

// MinElapsedTime estimates the minimum real time represented by this proof.
// Based on sequential squaring rate on typical hardware.
func (p *PietrzakProof) MinElapsedTime(squaringsPerSecond uint64) time.Duration {
	if squaringsPerSecond == 0 {
		squaringsPerSecond = 1000000 // Default: 1M squarings/sec
	}

	seconds := float64(p.T) / float64(squaringsPerSecond)
	return time.Duration(seconds * float64(time.Second))
}

// CalibrateSquaringsPerSecond measures the squaring rate on this machine.
func CalibrateSquaringsPerSecond(duration time.Duration) (uint64, error) {
	if duration < 100*time.Millisecond {
		return 0, errors.New("calibration duration too short")
	}

	n := defaultModulus
	x := big.NewInt(2)

	count := uint64(0)
	start := time.Now()
	deadline := start.Add(duration)

	for time.Now().Before(deadline) {
		// Batch 100 squarings
		for i := 0; i < 100; i++ {
			x.Mul(x, x)
			x.Mod(x, n)
			count++
		}
	}

	elapsed := time.Since(start)
	rate := uint64(float64(count) / elapsed.Seconds())

	return rate, nil
}

// ComputeWithDuration computes a VDF proof that represents approximately
// the given duration of sequential work.
func (v *PietrzakVDF) ComputeWithDuration(x *big.Int, targetDuration time.Duration, squaringsPerSecond uint64) (*PietrzakProof, error) {
	// Calculate required squarings
	t := uint64(targetDuration.Seconds() * float64(squaringsPerSecond))

	if t == 0 {
		t = 1
	}

	// Update params for this computation
	params := v.params
	params.T = t

	vdf, err := NewPietrzakVDF(params)
	if err != nil {
		return nil, err
	}

	return vdf.Evaluate(x)
}

// VerifyMinDuration verifies the proof and checks that it represents
// at least the specified minimum duration.
func (v *PietrzakVDF) VerifyMinDuration(proof *PietrzakProof, minDuration time.Duration, squaringsPerSecond uint64) error {
	// First verify the proof is valid
	if !v.Verify(proof) {
		return ErrInvalidProof
	}

	// Check minimum duration
	actualDuration := proof.MinElapsedTime(squaringsPerSecond)
	if actualDuration < minDuration {
		return fmt.Errorf("proof represents %v, minimum required is %v", actualDuration, minDuration)
	}

	return nil
}
