// This file is automatically generated, so please do not edit it.
// @generated by `flutter_rust_bridge`@ 2.11.1.

// ignore_for_file: invalid_use_of_internal_member, unused_import, unnecessary_import

import 'frb_generated.dart';
import 'package:flutter_rust_bridge/flutter_rust_bridge_for_generated.dart';

// These function are ignored because they are on traits that is not defined in current crate (put an empty `#[frb]` on it to unignore): `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `clone`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `fmt`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`, `from`

/// Initialize witnessd with optional custom data directory and mnemonic.
///
/// Creates the necessary directory structure and identity.
/// Returns the identity fingerprint on success.
Future<String> initWitnessd({String? dataDir, String? mnemonic}) => RustLib
    .instance
    .api
    .crateBridgeInitWitnessd(dataDir: dataDir, mnemonic: mnemonic);

/// Get the current identity fingerprint.
///
/// Returns None if witnessd is not initialized.
Future<String?> getIdentityFingerprint() =>
    RustLib.instance.api.crateBridgeGetIdentityFingerprint();

/// Check if witnessd is properly initialized.
Future<bool> isInitialized() => RustLib.instance.api.crateBridgeIsInitialized();

/// Setup identity with a specific mnemonic phrase.
Future<String> setupIdentity({required String phrase}) =>
    RustLib.instance.api.crateBridgeSetupIdentity(phrase: phrase);

/// Generate a new mnemonic phrase for identity creation.
Future<String> generateMnemonic() =>
    RustLib.instance.api.crateBridgeGenerateMnemonic();

/// Create a checkpoint for a document.
///
/// Records the current state of the document with optional message.
/// Returns checkpoint information.
Future<FrbCheckpointInfo> commitDocument({
  required String path,
  String? message,
}) => RustLib.instance.api.crateBridgeCommitDocument(
  path: path,
  message: message,
);

/// Get the checkpoint history for a document.
///
/// Returns array of checkpoint information.
Future<List<FrbCheckpointInfo>> getDocumentLog({required String path}) =>
    RustLib.instance.api.crateBridgeGetDocumentLog(path: path);

/// Verify the integrity of a document's checkpoint chain.
///
/// Returns verification result.
Future<FrbVerificationResult> verifyDocument({required String path}) =>
    RustLib.instance.api.crateBridgeVerifyDocument(path: path);

/// Export an evidence packet for a document.
///
/// Creates a comprehensive evidence packet.
/// Returns export result with output path.
Future<FrbExportResult> exportEvidence({
  required String path,
  required String title,
  required String tier,
}) => RustLib.instance.api.crateBridgeExportEvidence(
  path: path,
  title: title,
  tier: tier,
);

/// Start keystroke tracking for a document.
Future<void> startTracking({required String path}) =>
    RustLib.instance.api.crateBridgeStartTracking(path: path);

/// Stop the current keystroke tracking session.
///
/// Returns tracking statistics.
Future<FrbTrackingStatistics> stopTracking() =>
    RustLib.instance.api.crateBridgeStopTracking();

/// Record a keystroke event.
///
/// Returns (jitter_micros, sample_created).
Future<(int, bool)> recordKeystroke() =>
    RustLib.instance.api.crateBridgeRecordKeystroke();

/// Get the current tracking session status.
///
/// Returns tracking status.
Future<FrbTrackingStatus> getTrackingStatus() =>
    RustLib.instance.api.crateBridgeGetTrackingStatus();

/// Get keystroke statistics from the current tracking session.
///
/// Returns statistics.
Future<FrbTrackingStatistics> getTrackingStatistics() =>
    RustLib.instance.api.crateBridgeGetTrackingStatistics();

/// Start a presence verification session.
///
/// Returns the session ID.
Future<String> startPresenceSession() =>
    RustLib.instance.api.crateBridgeStartPresenceSession();

/// End the current presence verification session.
///
/// Returns presence status summary.
Future<FrbPresenceStatus> endPresenceSession() =>
    RustLib.instance.api.crateBridgeEndPresenceSession();

/// Get the current pending challenge, if any.
///
/// Returns challenge info, or None.
Future<FrbChallengeInfo?> getPendingChallenge() =>
    RustLib.instance.api.crateBridgeGetPendingChallenge();

/// Submit a response to the current challenge.
///
/// Returns true if the response was correct.
Future<bool> submitChallengeResponse({required String response}) =>
    RustLib.instance.api.crateBridgeSubmitChallengeResponse(response: response);

/// Get the current presence verification status.
///
/// Returns presence status.
Future<FrbPresenceStatus> getPresenceStatus() =>
    RustLib.instance.api.crateBridgeGetPresenceStatus();

/// Run forensic analysis on a document.
///
/// Returns forensic report.
Future<FrbForensicReport> analyzeDocument({required String path}) =>
    RustLib.instance.api.crateBridgeAnalyzeDocument(path: path);

/// Get the typing cadence score for a document.
///
/// Returns a score from 0.0 to 1.0 indicating consistency with original composition.
Future<double> getCadenceScore({required String path}) =>
    RustLib.instance.api.crateBridgeGetCadenceScore(path: path);

/// Get the forensic score for a file (legacy API).
Future<double> getForensicScore({required String filePath}) =>
    RustLib.instance.api.crateBridgeGetForensicScore(filePath: filePath);

/// Get the current application configuration.
///
/// Returns configuration.
Future<FrbAppConfig> getConfig() => RustLib.instance.api.crateBridgeGetConfig();

/// Update the application configuration.
///
/// Takes configuration.
Future<void> setConfig({required FrbAppConfig config}) =>
    RustLib.instance.api.crateBridgeSetConfig(config: config);

/// Get current VDF parameters.
///
/// Returns VDF parameters.
Future<FrbVdfParams> getVdfParams() =>
    RustLib.instance.api.crateBridgeGetVdfParams();

/// Run VDF calibration and return optimized parameters.
///
/// Returns calibrated VDF parameters.
Future<FrbVdfParams> calibrateVdf() =>
    RustLib.instance.api.crateBridgeCalibrateVdf();

/// Start the witnessing engine with default configuration.
///
/// Returns engine status.
Future<FrbEngineStatus> startEngine() =>
    RustLib.instance.api.crateBridgeStartEngine();

/// Stop the witnessing engine.
Future<void> stopEngine() => RustLib.instance.api.crateBridgeStopEngine();

/// Get the current engine status.
///
/// Returns engine status, or None if engine is not running.
Future<FrbEngineStatus?> engineStatus() =>
    RustLib.instance.api.crateBridgeEngineStatus();

/// Get list of files being tracked by the engine.
///
/// Returns array of file reports.
Future<List<FrbReportFile>> reportFiles() =>
    RustLib.instance.api.crateBridgeReportFiles();

/// Get the engine configuration.
Future<FrbEngineConfig> getEngineConfig() =>
    RustLib.instance.api.crateBridgeGetEngineConfig();

/// Set the engine configuration.
Future<void> setEngineConfig({required FrbEngineConfig config}) =>
    RustLib.instance.api.crateBridgeSetEngineConfig(config: config);

/// Check hardware security capabilities.
///
/// Returns hardware status.
Future<FrbHardwareStatus> checkHardwareStatus() =>
    RustLib.instance.api.crateBridgeCheckHardwareStatus();

/// Check if accessibility permissions are granted (macOS).
Future<bool> accessibilityTrusted() =>
    RustLib.instance.api.crateBridgeAccessibilityTrusted();

/// Open accessibility settings (macOS).
Future<void> openAccessibilitySettings() =>
    RustLib.instance.api.crateBridgeOpenAccessibilitySettings();

/// Request accessibility permissions (macOS).
Future<bool> requestAccessibilityPermissions() =>
    RustLib.instance.api.crateBridgeRequestAccessibilityPermissions();

/// Check if input monitoring permissions are granted (macOS).
Future<bool> inputMonitoringTrusted() =>
    RustLib.instance.api.crateBridgeInputMonitoringTrusted();

/// Request input monitoring permissions (macOS).
Future<bool> requestInputMonitoringPermissions() =>
    RustLib.instance.api.crateBridgeRequestInputMonitoringPermissions();

/// Open input monitoring settings (macOS).
Future<void> openInputMonitoringSettings() =>
    RustLib.instance.api.crateBridgeOpenInputMonitoringSettings();

/// Get the application version.
Future<String> getVersion() => RustLib.instance.api.crateBridgeGetVersion();

/// Check if running on a supported platform.
Future<bool> isSupportedPlatform() =>
    RustLib.instance.api.crateBridgeIsSupportedPlatform();

/// Get the current platform name.
Future<String> getPlatform() => RustLib.instance.api.crateBridgeGetPlatform();

/// App config for direct FRB transfer.
class FrbAppConfig {
  final String dataDir;
  final List<String> watchDirs;
  final int retentionDays;
  final BigInt presenceChallengeIntervalSecs;
  final BigInt presenceResponseWindowSecs;
  final FrbVdfParams vdfParams;

  const FrbAppConfig({
    required this.dataDir,
    required this.watchDirs,
    required this.retentionDays,
    required this.presenceChallengeIntervalSecs,
    required this.presenceResponseWindowSecs,
    required this.vdfParams,
  });

  @override
  int get hashCode =>
      dataDir.hashCode ^
      watchDirs.hashCode ^
      retentionDays.hashCode ^
      presenceChallengeIntervalSecs.hashCode ^
      presenceResponseWindowSecs.hashCode ^
      vdfParams.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbAppConfig &&
          runtimeType == other.runtimeType &&
          dataDir == other.dataDir &&
          watchDirs == other.watchDirs &&
          retentionDays == other.retentionDays &&
          presenceChallengeIntervalSecs ==
              other.presenceChallengeIntervalSecs &&
          presenceResponseWindowSecs == other.presenceResponseWindowSecs &&
          vdfParams == other.vdfParams;
}

/// Challenge info for direct FRB transfer.
class FrbChallengeInfo {
  final String id;
  final String challengeType;
  final String prompt;
  final String issuedAt;
  final String expiresAt;
  final double windowSecs;

  const FrbChallengeInfo({
    required this.id,
    required this.challengeType,
    required this.prompt,
    required this.issuedAt,
    required this.expiresAt,
    required this.windowSecs,
  });

  @override
  int get hashCode =>
      id.hashCode ^
      challengeType.hashCode ^
      prompt.hashCode ^
      issuedAt.hashCode ^
      expiresAt.hashCode ^
      windowSecs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbChallengeInfo &&
          runtimeType == other.runtimeType &&
          id == other.id &&
          challengeType == other.challengeType &&
          prompt == other.prompt &&
          issuedAt == other.issuedAt &&
          expiresAt == other.expiresAt &&
          windowSecs == other.windowSecs;
}

/// Checkpoint info for direct FRB transfer without JSON.
class FrbCheckpointInfo {
  final BigInt ordinal;
  final String timestamp;
  final String contentHash;
  final PlatformInt64 contentSize;
  final String? message;
  final bool hasVdfProof;
  final double? elapsedTimeSecs;

  const FrbCheckpointInfo({
    required this.ordinal,
    required this.timestamp,
    required this.contentHash,
    required this.contentSize,
    this.message,
    required this.hasVdfProof,
    this.elapsedTimeSecs,
  });

  @override
  int get hashCode =>
      ordinal.hashCode ^
      timestamp.hashCode ^
      contentHash.hashCode ^
      contentSize.hashCode ^
      message.hashCode ^
      hasVdfProof.hashCode ^
      elapsedTimeSecs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbCheckpointInfo &&
          runtimeType == other.runtimeType &&
          ordinal == other.ordinal &&
          timestamp == other.timestamp &&
          contentHash == other.contentHash &&
          contentSize == other.contentSize &&
          message == other.message &&
          hasVdfProof == other.hasVdfProof &&
          elapsedTimeSecs == other.elapsedTimeSecs;
}

/// Engine config for direct FRB transfer.
class FrbEngineConfig {
  final String dataDir;
  final List<String> watchDirs;
  final int retentionDays;

  const FrbEngineConfig({
    required this.dataDir,
    required this.watchDirs,
    required this.retentionDays,
  });

  @override
  int get hashCode =>
      dataDir.hashCode ^ watchDirs.hashCode ^ retentionDays.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbEngineConfig &&
          runtimeType == other.runtimeType &&
          dataDir == other.dataDir &&
          watchDirs == other.watchDirs &&
          retentionDays == other.retentionDays;
}

/// Engine status for direct FRB transfer.
class FrbEngineStatus {
  final bool running;
  final bool accessibilityTrusted;
  final List<String> watchDirs;
  final BigInt eventsWritten;
  final BigInt jitterSamples;
  final PlatformInt64? lastEventTimestampNs;

  const FrbEngineStatus({
    required this.running,
    required this.accessibilityTrusted,
    required this.watchDirs,
    required this.eventsWritten,
    required this.jitterSamples,
    this.lastEventTimestampNs,
  });

  @override
  int get hashCode =>
      running.hashCode ^
      accessibilityTrusted.hashCode ^
      watchDirs.hashCode ^
      eventsWritten.hashCode ^
      jitterSamples.hashCode ^
      lastEventTimestampNs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbEngineStatus &&
          runtimeType == other.runtimeType &&
          running == other.running &&
          accessibilityTrusted == other.accessibilityTrusted &&
          watchDirs == other.watchDirs &&
          eventsWritten == other.eventsWritten &&
          jitterSamples == other.jitterSamples &&
          lastEventTimestampNs == other.lastEventTimestampNs;
}

/// Export result for direct FRB transfer.
class FrbExportResult {
  final bool success;
  final String? outputPath;
  final String? packetHash;
  final String? error;

  const FrbExportResult({
    required this.success,
    this.outputPath,
    this.packetHash,
    this.error,
  });

  @override
  int get hashCode =>
      success.hashCode ^
      outputPath.hashCode ^
      packetHash.hashCode ^
      error.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbExportResult &&
          runtimeType == other.runtimeType &&
          success == other.success &&
          outputPath == other.outputPath &&
          packetHash == other.packetHash &&
          error == other.error;
}

/// Forensic report for direct FRB transfer.
class FrbForensicReport {
  final double confidenceScore;
  final bool isAnomaly;
  final bool isRetypedContent;
  final int signalCount;

  const FrbForensicReport({
    required this.confidenceScore,
    required this.isAnomaly,
    required this.isRetypedContent,
    required this.signalCount,
  });

  @override
  int get hashCode =>
      confidenceScore.hashCode ^
      isAnomaly.hashCode ^
      isRetypedContent.hashCode ^
      signalCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbForensicReport &&
          runtimeType == other.runtimeType &&
          confidenceScore == other.confidenceScore &&
          isAnomaly == other.isAnomaly &&
          isRetypedContent == other.isRetypedContent &&
          signalCount == other.signalCount;
}

/// Hardware status for direct FRB transfer.
class FrbHardwareStatus {
  final bool enclaveActive;
  final bool tpmActive;
  final String siliconId;

  const FrbHardwareStatus({
    required this.enclaveActive,
    required this.tpmActive,
    required this.siliconId,
  });

  @override
  int get hashCode =>
      enclaveActive.hashCode ^ tpmActive.hashCode ^ siliconId.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbHardwareStatus &&
          runtimeType == other.runtimeType &&
          enclaveActive == other.enclaveActive &&
          tpmActive == other.tpmActive &&
          siliconId == other.siliconId;
}

/// Presence status for direct FRB transfer.
class FrbPresenceStatus {
  final bool sessionActive;
  final String? sessionId;
  final String? startedAt;
  final int challengesIssued;
  final int challengesPassed;
  final int challengesFailed;
  final int challengesMissed;
  final double verificationRate;
  final bool hasPendingChallenge;

  const FrbPresenceStatus({
    required this.sessionActive,
    this.sessionId,
    this.startedAt,
    required this.challengesIssued,
    required this.challengesPassed,
    required this.challengesFailed,
    required this.challengesMissed,
    required this.verificationRate,
    required this.hasPendingChallenge,
  });

  @override
  int get hashCode =>
      sessionActive.hashCode ^
      sessionId.hashCode ^
      startedAt.hashCode ^
      challengesIssued.hashCode ^
      challengesPassed.hashCode ^
      challengesFailed.hashCode ^
      challengesMissed.hashCode ^
      verificationRate.hashCode ^
      hasPendingChallenge.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbPresenceStatus &&
          runtimeType == other.runtimeType &&
          sessionActive == other.sessionActive &&
          sessionId == other.sessionId &&
          startedAt == other.startedAt &&
          challengesIssued == other.challengesIssued &&
          challengesPassed == other.challengesPassed &&
          challengesFailed == other.challengesFailed &&
          challengesMissed == other.challengesMissed &&
          verificationRate == other.verificationRate &&
          hasPendingChallenge == other.hasPendingChallenge;
}

/// Report file for direct FRB transfer.
class FrbReportFile {
  final String filePath;
  final PlatformInt64 lastEventTimestampNs;
  final BigInt eventCount;

  const FrbReportFile({
    required this.filePath,
    required this.lastEventTimestampNs,
    required this.eventCount,
  });

  @override
  int get hashCode =>
      filePath.hashCode ^ lastEventTimestampNs.hashCode ^ eventCount.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbReportFile &&
          runtimeType == other.runtimeType &&
          filePath == other.filePath &&
          lastEventTimestampNs == other.lastEventTimestampNs &&
          eventCount == other.eventCount;
}

/// Tracking statistics for direct FRB transfer.
class FrbTrackingStatistics {
  final BigInt totalKeystrokes;
  final int totalSamples;
  final double durationSecs;
  final double keystrokesPerMin;
  final int uniqueDocHashes;
  final bool chainValid;

  const FrbTrackingStatistics({
    required this.totalKeystrokes,
    required this.totalSamples,
    required this.durationSecs,
    required this.keystrokesPerMin,
    required this.uniqueDocHashes,
    required this.chainValid,
  });

  @override
  int get hashCode =>
      totalKeystrokes.hashCode ^
      totalSamples.hashCode ^
      durationSecs.hashCode ^
      keystrokesPerMin.hashCode ^
      uniqueDocHashes.hashCode ^
      chainValid.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbTrackingStatistics &&
          runtimeType == other.runtimeType &&
          totalKeystrokes == other.totalKeystrokes &&
          totalSamples == other.totalSamples &&
          durationSecs == other.durationSecs &&
          keystrokesPerMin == other.keystrokesPerMin &&
          uniqueDocHashes == other.uniqueDocHashes &&
          chainValid == other.chainValid;
}

/// Tracking status for direct FRB transfer.
class FrbTrackingStatus {
  final bool active;
  final String? sessionId;
  final String? documentPath;
  final String? startedAt;
  final BigInt keystrokeCount;
  final int sampleCount;
  final double durationSecs;

  const FrbTrackingStatus({
    required this.active,
    this.sessionId,
    this.documentPath,
    this.startedAt,
    required this.keystrokeCount,
    required this.sampleCount,
    required this.durationSecs,
  });

  @override
  int get hashCode =>
      active.hashCode ^
      sessionId.hashCode ^
      documentPath.hashCode ^
      startedAt.hashCode ^
      keystrokeCount.hashCode ^
      sampleCount.hashCode ^
      durationSecs.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbTrackingStatus &&
          runtimeType == other.runtimeType &&
          active == other.active &&
          sessionId == other.sessionId &&
          documentPath == other.documentPath &&
          startedAt == other.startedAt &&
          keystrokeCount == other.keystrokeCount &&
          sampleCount == other.sampleCount &&
          durationSecs == other.durationSecs;
}

/// VDF parameters for direct FRB transfer.
class FrbVdfParams {
  final BigInt iterationsPerSecond;
  final BigInt minIterations;
  final BigInt maxIterations;

  const FrbVdfParams({
    required this.iterationsPerSecond,
    required this.minIterations,
    required this.maxIterations,
  });

  @override
  int get hashCode =>
      iterationsPerSecond.hashCode ^
      minIterations.hashCode ^
      maxIterations.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbVdfParams &&
          runtimeType == other.runtimeType &&
          iterationsPerSecond == other.iterationsPerSecond &&
          minIterations == other.minIterations &&
          maxIterations == other.maxIterations;
}

/// Verification result for direct FRB transfer.
class FrbVerificationResult {
  final bool valid;
  final int checkpointCount;
  final double totalElapsedTimeSecs;
  final String? firstCommit;
  final String? lastCommit;
  final List<String> errors;

  const FrbVerificationResult({
    required this.valid,
    required this.checkpointCount,
    required this.totalElapsedTimeSecs,
    this.firstCommit,
    this.lastCommit,
    required this.errors,
  });

  @override
  int get hashCode =>
      valid.hashCode ^
      checkpointCount.hashCode ^
      totalElapsedTimeSecs.hashCode ^
      firstCommit.hashCode ^
      lastCommit.hashCode ^
      errors.hashCode;

  @override
  bool operator ==(Object other) =>
      identical(this, other) ||
      other is FrbVerificationResult &&
          runtimeType == other.runtimeType &&
          valid == other.valid &&
          checkpointCount == other.checkpointCount &&
          totalElapsedTimeSecs == other.totalElapsedTimeSecs &&
          firstCommit == other.firstCommit &&
          lastCommit == other.lastCommit &&
          errors == other.errors;
}
